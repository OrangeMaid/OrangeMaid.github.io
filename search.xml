<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/09/29/interviewAnalyse/explain/"/>
      <url>/2020/09/29/interviewAnalyse/explain/</url>
      
        <content type="html"><![CDATA[<h2 id="1、如何优化和分析sql执行过程？"><a href="#1、如何优化和分析sql执行过程？" class="headerlink" title="1、如何优化和分析sql执行过程？"></a>1、如何优化和分析sql执行过程？</h2><h3 id="1-1-explain简介"><a href="#1-1-explain简介" class="headerlink" title="1.1 explain简介"></a>1.1 explain简介</h3><p>使用explain关键字可以模拟优化器的执行SQL查询语句，从而了解到MySQL是如何处理一条sql语句的</p><h3 id="1-2-通过explain，可以分析出一下结果："><a href="#1-2-通过explain，可以分析出一下结果：" class="headerlink" title="1.2 通过explain，可以分析出一下结果："></a>1.2 通过explain，可以分析出一下结果：</h3><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>那些索引可以使用</li><li>那些索引命中</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h3 id="1-3使用方法"><a href="#1-3使用方法" class="headerlink" title="1.3使用方法"></a>1.3使用方法</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> sale_order_goods t <span class="token keyword">WHERE</span> t<span class="token punctuation">.</span>order_code <span class="token operator">=</span> <span class="token string">'100000005466'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/java20200929215227.png"></p><h3 id="1-4-名词解析"><a href="#1-4-名词解析" class="headerlink" title="1.4 名词解析"></a>1.4 名词解析</h3><ul><li>id:选择标识符</li><li>select_type:表示查询的类型。</li><li>table:输出结果集的表</li><li>partitions:匹配的分区</li><li>type:表示表的连接类型</li><li>possible_keys:表示查询时，可能使用的索引</li><li>key:表示实际使用的索引</li><li>key_len:索引字段的长度</li><li>ref:列与索引的比较</li><li>rows:扫描出的行数(估算的行数)</li><li>filtered:按表条件过滤的行百分比</li><li>Extra:执行情况的描述和说明</li></ul><h4 id="一、-id"><a href="#一、-id" class="headerlink" title="一、 id"></a>一、 <strong>id</strong></h4><p>SELECT识别符。这是SELECT的查询序列号</p><p><strong>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</strong></p><p>（1）id相同时，执行顺序由上至下</p><p>（2）如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><p>（3）id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><p><strong>二、select_type</strong> </p><p>查询每个select子句的类型</p><p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p><p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p><p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p><p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p><p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p><p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p><p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p><p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p><p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><p><strong>三、table</strong></p><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><p><strong>四、type</strong></p><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、****NULL（从左到右，性能从差到好）</strong></p><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p><p>range:只检索给定范围的行，使用一个索引来选择行</p><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><p><strong>五、possible_keys</strong></p><p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</strong></p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><p><strong>六、Key</strong></p><p><strong>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</strong></p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX</p><p><strong>七、key_len</strong></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p>不损失精确性的情况下，长度越短越好 </p><p><strong>八、ref</strong></p><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p><strong>九、rows</strong></p><p> 估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><p><strong>十、Extra</strong></p><p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p><pre class="line-numbers language-none"><code class="language-none">-- 测试Extra的filesortexplain select * from emp order by name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p>No tables used：Query语句中使用from dual 或不含任何from子句</p><pre class="line-numbers language-none"><code class="language-none">-- explain select now() from dual;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、如何保证系统的幂等性？"><a href="#2、如何保证系统的幂等性？" class="headerlink" title="2、如何保证系统的幂等性？"></a>2、如何保证系统的幂等性？</h2><h2 id="3、mq如何保证消息顺序消费？"><a href="#3、mq如何保证消息顺序消费？" class="headerlink" title="3、mq如何保证消息顺序消费？"></a>3、mq如何保证消息顺序消费？</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/21/Java/%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81/"/>
      <url>/2020/09/21/Java/%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * * @Description: 双重校验锁单例模式&lt;br> * @CreateDate: Created in 2020/9/21 16:53 &lt;br> */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> singleton<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> singleton<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试复盘</title>
      <link href="/2020/09/11/interviewAnalyse/interviewByLiang/"/>
      <url>/2020/09/11/interviewAnalyse/interviewByLiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Spring事务的传播行为？"><a href="#1、Spring事务的传播行为？" class="headerlink" title="1、Spring事务的传播行为？"></a>1、Spring事务的传播行为？</h2><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h2 id="2、zk集群宕机了，还能提供服务吗？本地缓存何时刷新？"><a href="#2、zk集群宕机了，还能提供服务吗？本地缓存何时刷新？" class="headerlink" title="2、zk集群宕机了，还能提供服务吗？本地缓存何时刷新？"></a>2、zk集群宕机了，还能提供服务吗？本地缓存何时刷新？</h2><p>可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用<br>注册中心对等集群，任意一台宕掉后，会自动切换到另一台注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯，服务提供者无状态，任一台 宕机后，不影响使用服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</p><h2 id="3、怎么保证mq的高可用性，比如说，一个时间点mq宕机了，如何保证消息推送到mq和正确消费？"><a href="#3、怎么保证mq的高可用性，比如说，一个时间点mq宕机了，如何保证消息推送到mq和正确消费？" class="headerlink" title="3、怎么保证mq的高可用性，比如说，一个时间点mq宕机了，如何保证消息推送到mq和正确消费？"></a>3、怎么保证mq的高可用性，比如说，一个时间点mq宕机了，如何保证消息推送到mq和正确消费？</h2><ul><li><h5 id="消息为什么会丢失？"><a href="#消息为什么会丢失？" class="headerlink" title="消息为什么会丢失？"></a>消息为什么会丢失？</h5></li></ul><p>RabbitMQ默认情况下的交换机和队列以及消息是非持久化的，也就是说在服务器重启或者宕机恢复后，之前创建的交换机和队列都将不复存在，之前未消费的消息也就消失不见了。原因在于每个队列和交换机的durable属性。该属性默认情况是false，它决定了RabbitMQ是否需要在崩溃或者重启之后重新创建队列（或者交换机）。</p><ul><li><h5 id="持久化交换机和队列"><a href="#持久化交换机和队列" class="headerlink" title="持久化交换机和队列?"></a>持久化交换机和队列?</h5></li></ul><p>将交换机和队列的durable属性设置为true，这样你就不需要在服务器断电后重新创建队列和交换机了。你也许会认为把队列和交换机的durable属性设置为true就足够可以让消息幸免于重启后丢失了，真的是这样吗？队列和交换机当然必须被设置为true，但光这样做还不够。<br>能从AMQP服务器崩溃中恢复的消息，我们称之为持久化消息。在消息发布前，通过把它的“投递默认”（ delivery mode）选项设置为2（AMQP客户端可能会使用人性化的常量来代替数值）来把消息标记成持久化。到目前为止，消息还只是被表示为持久化的，但是它还必须被发布到持久化的交换机中，并到达持久化的队列中才行。如果不是这样的话，则包含持久化消息的队列（或者交换机）会在Rabbit崩溃重启后不复存在，从而导致消息丢失。</p><ul><li><h5 id="持久化消息"><a href="#持久化消息" class="headerlink" title="持久化消息?"></a>持久化消息?</h5></li></ul><p>因此，如果消息想要从Rabbit崩溃中恢复，那么消息必须满足以下条件：</p><ol><li>把它的投递默认选项设置为持久化</li><li>发送到持久化的交换机</li><li>到达持久化的队列</li></ol><p>做到以上三点，你就不需要担心发送到Rabbit服务器的消息因服务器崩溃等其它原因而丢失了。</p><ul><li><h5 id="如何做到消息持久化的"><a href="#如何做到消息持久化的" class="headerlink" title="如何做到消息持久化的?"></a>如何做到消息持久化的?</h5></li></ul><p>RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件。当发布一个持久性消息到持久交换机上时，Rabbit会在消息提交到日志文件后才发送响应。记住，之后这条消息如果路由到了非持久队列的话，它会自动从持久性日志中移除，并且无法从服务器重启中恢复。如果你使用持久性消息的话，则确保之前提到的持久性消息的那三点都必须做到位。一旦你从持久性队列中消费了一个持久性消息的话（并且确认了它），RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。在你消费持久性消息前，如果RabbitMQ重启的话，服务器会自动重建交换机和队列（以及绑定），重播持久性日志文件的消息到合适的队列或者交换机上（取决于Rabbit服务器宕机的时候，消息处在路由过程的哪个环节）。<br>虽然持久化消息可以做到消息的不丢失，但持久化的消息在进入队列前会被写到磁盘，这个过程比写到内存慢得多，所以会严重的影响性能，可能导致消息的吞吐量降低10倍不止。所以，在做消息持久化前，一定要认真考虑性能和需求之间的平衡关系。</p><h2 id="4、类加载的过程"><a href="#4、类加载的过程" class="headerlink" title="4、类加载的过程"></a>4、类加载的过程</h2><h3 id="4-1、Class-文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些-Class-文件呢？"><a href="#4-1、Class-文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些-Class-文件呢？" class="headerlink" title="4.1、Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？"></a>4.1、Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</h3><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><ul><li><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4>类加载过程的第一步，主要完成下面3件事情：</li></ul><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><ul><li><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3></li><li><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3></li></ul><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><ul><li><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3></li></ul><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><ul><li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li></ul><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code>方法的过程。</p><p>对于<code>&lt;clinit&gt;（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li></ol><ul><li><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3></li></ul><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ol><p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><blockquote><p>转载：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B</a></p></blockquote><h2 id="待续。。。。。"><a href="#待续。。。。。" class="headerlink" title="待续。。。。。"></a>待续。。。。。</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海贼王</title>
      <link href="/2020/09/07/Life/%E6%B5%B7%E8%B4%BC%E7%8E%8B%E8%AF%AD%E5%BD%95/"/>
      <url>/2020/09/07/Life/%E6%B5%B7%E8%B4%BC%E7%8E%8B%E8%AF%AD%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="海贼王语录"><a href="#海贼王语录" class="headerlink" title="海贼王语录"></a>海贼王语录</h3><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/Logo_haizeiwang.jpg"></p><p>1.比如说有一块肉，英雄会把它分给别人，而海贼会拿它来开宴会。我喜欢吃肉！我不是英雄，我只做我想做的事，保护我想要保护的人而已。——路飞《海贼王》</p><p>2.只管把目标定在高峰，人家要笑就让他去笑！——马歇尔•D•蒂奇《海贼王》</p><p>3.对不起，我对活一千年没有兴趣，我只要今天能活着就好。——波特卡斯•D•艾斯《海贼王》</p><p>4.不要随随便便同情失败者，这会伤了他的自尊心。——山治《海贼王》</p><p>5.所有人都知道，自由并不是放纵，那是火一般的梦想。——波特卡斯D艾斯《海贼王》</p><p>6.我不是天生的王者，但我骨子里流动着不让我低头的血液。——蒙奇•D•路飞《海贼王》</p><p>7.一个人的死，对于这个世界来说不过是多了一座坟墓，但对于相依为命的人来说，却是整个世界都被坟墓掩埋。——《海贼王》</p><p>8.为什么遇到如此强大的敌人你也不愿逃跑？—— 那是因为身后，有至爱之人。——波特卡斯•D•艾斯《海贼王》</p><p>9.我不管这个世上的人怎么说我，我只想依照我的信念做事，绝不后悔，不管现在将来都一样！——索隆《海贼王》</p><p>10.人什么时候才会死？被子弹贯穿心脏的时候？不对！得了不治之症的时候？不对！喝下毒蘑菇汤的时候？不对！是被人遗忘的时候！——《海贼王》</p><p>11.这个世界并不是掌握在那些嘲笑者的手中，而恰恰掌握在能够经受得住嘲笑与批评仍不断往前走的人手中。——《海贼王》</p><p>12.人生中有些事你不竭尽所能去做，你永远不知道你自己有多出色 ——索隆</p><p>13.不知所措，才是人生。——冥王•雷利《海贼王》</p><p>14.除非我不想赢，否则没有人能让我输！——《海贼王》</p><p>15.遇到迷茫时，任何人都会变得软弱。一旦坚信自己可以帮到别人，他们就会变得很强大。——娜美《海贼王》</p><p>16.灾难总是接踵而至，这正是世间的常理。你以为只要解释一下，就有谁会来救你吗？要是死了，就只能说明我不过是如此程度的男人。——罗罗诺亚•索隆《海贼王》</p><p>17.在这片海洋中，若无法向上攀游，就只有往下沉沦，是要前进或是溺死，就得看自己的选择。既然这么不甘心，就变的更强！——斯摩格《海贼王》</p><p>18.弱者，连死的方式都无从选择。——堂吉诃德•多弗朗明哥《海贼王》</p><p>19.永远也不要忘记能够笑的坚强，就算受伤，我们也从不彷徨。——《海贼王》</p><p>20.人生充满了起起落落。关键在于，在顶端时好好享受；在低谷时不失勇气。——《海贼王》</p><p>21.能原谅女人谎言的才是真正的男人。——山治《海贼王》</p><p>22.如果你坚持了自己的梦想，全世界都会为你让路。——《海贼王》</p><p>23.所谓理想，只是同时拥有实力的人才能说的“现实”。所谓弱就是一种罪。——沙克洛克达尔《海贼王》</p><p>24.将过去和羁绊全部丢弃,不要吝惜那为了梦想流下的泪水。——蒙奇•D•路飞《海贼王》</p><p>25.历史虽然会一再重演，但人类却无法回到过去。——妮可•罗宾《海贼王》</p><p>26.只要把垃圾都藏在黑暗之中，世界看起来自然就歌舞升平了。——尾田荣一郎《海贼王》</p><p>27.我不是英雄，我只做我想做的事，保护我想要保护的人而已。——路飞《海贼王》</p><p>28.永远也不要忘记能够笑的坚强。——尾田荣一郎《海贼王》</p><p>29.既然已经决定做一件事，那么除了当初决定做这件事的我之外，没人可以叫我傻瓜。——索隆《海贼王》</p><p>30.你没听过这句伟大的名言么？“肚子饿了就要吃！”——蒙其•D•路飞《海贼王》</p><p>31.我做不到的由你来，你做不到的由我来。——山治《海贼王》</p><p>32.胜利和败北都要品尝、经历过四处逃窜的辛酸、痛苦和悲伤的回忆、这样才能独当一面、就算痛哭流涕也没关系！——红发《海贼王》</p><p>33.如果一直想着麻烦的事，只会更麻烦。——罗罗诺亚•索隆《海贼王》</p><p>34.按照自己的喜好去做,得不到别人的赞赏也没关系。——贝尔梅丽《海贼王》</p><p>35.人的梦想，是不会终结的！——马歇尔•D•蒂奇《海贼王》</p><p>36.可是 ，团队精神到底是什么啊？互相帮助互相袒护就算是吗 ？也有人这么认为吧 ！我是认为那根本只是唬人 ！应该是每个人抱着必死的决心做自己的事！”我做好自己的部分了，接下来轮到你了，做不好的话我就揍扁你！“要有这种决心才算是起码的团队精神吧！所以从这点考虑的话 ，就算伙伴都是特立独行的人也没什么大不了的 ！我是这么想的。——索隆《海贼王》<br>37.谁也没有办法把过去发生的事情一笔勾销，要记住教训，勇敢的活下去。——《海贼王》</p><p>38.让我存活于这世上的力量既不是内脏也不是肌肉，没错，是灵魂。——布鲁克《海贼王》</p><p>39.受尽苦难而不厌，此乃修罗之道。——索隆《海贼王》</p><p>40.就算彼此错过也是一种缘分！——马歇尔•D•蒂奇《海贼王》</p><p>41.骂人可以不带脏字，干架也不见得非得动拳头！——马歇尔•D•蒂奇《海贼王》</p><p>42.听着……乔巴，男子汉，即……即使……遇……到可能会杀死自己的强敌……也，也不能倒下。就算对方是……死也赢不了的敌人……男人……有时候是绝对不能逃避……战斗的……！尤其……尤其是当……伙伴的梦想……被人嘲笑的时候！——乌索普《海贼王》</p><p>43.要是错过了，肯定会后悔一辈子的。——路飞《海贼王》</p><p>44.以前的事不可能忘掉的 也没必要忘掉！可是更重要的应该是未来的事才对吧。《海贼王》</p><p>45.是死是活都听天由命，害怕的话你就输了！——马歇尔•D•蒂奇《海贼王》</p><p>46.痛苦的时候不能在一起的话，那还算什么同伴。——《海贼王507集》</p><p>47.一个人只要多笑，就会变得很幸福。——哈古瓦尔•D•萨乌罗《海贼王》</p><p>48.如果不树立危机感，你就无法成长。——士兵先生《海贼王》</p><p>49.一个人诞生在这个世界上，绝对不会是永远孤单的。——哈古瓦尔•D•萨乌罗《海贼王》</p><p>50.一个人的力量是有限度的，不论想做什么事，一个人的力量是不够的，人是需要同伴的!——尾田荣一郎《海贼王》</p><p>51.我的船上没有手下……只有伙伴！——尾田荣一郎《海贼王》</p><p>52.路飞:我不会剑术,不懂航海,不会烧菜,更不会吹牛。阿龙:那你能干什么? 路飞:我能打赢你!——《海贼王》</p><p>53.伤心的时候只要开怀笑就行了！——萨龙《海贼王》</p><p>54.即使会使普通人昏倒的伤，我也绝对不能倒下！即使会使普通人死掉的伤，我也不可以死…因为如果我是普通人，就绝对赢不了“鹰眼”，所以我不可以是普通人！——索隆《海贼王》</p><p>55.那真可惜了，我从来就没有向神祈祷过。我根本不相信有神，更不会尊敬他——索隆《海贼王》</p><p>56.我的人生，没有遗憾，其实我真正想要的东西并不是名声。我想知道的只是自己应不应该被生下来的答案。——波特卡斯•D•艾斯《海贼王》</p><p>57.坏蛋也好，什么都好，反正我要我的名字轰动全世界！——尾田荣一郎《海贼王》</p><p>58.打架论什么头衔太没意思了，胜者为王，就这么简单。——索隆《海贼王》</p><p>59.奇迹只会降临在不言放弃的人身上，不要小看奇迹！——尾田荣一郎《海贼王》</p><p>60.只要被人说是弱者就气得浑身发抖的，那他就是真正的弱者！——《One Piece》</p><p>61.听好了，路飞。我们一定要——活得没有遗憾哦！总有一天要出海！随心所欲地活着！比谁都要自由！——波特卡斯•D•艾斯《海贼王》</p><p>62.还有一件让我放心不下的事，就是不能看到你实现梦想的那一时刻。——波特卡斯•D•艾斯《海贼王》</p><p>63.也许这个世界上并没有偶然，有的只是必然。“缘”不紧不慢地悄然形成。——雷利《海贼王》</p><p>64.请把那把刀给我吧！我要会连她的份也一起努力的，我要成为世界第一的大剑客，我要让我的名字，响彻天堂！——索隆《海贼王》</p><p>65.痛是你活着的证明。——伦巴海贼团约基船长《海贼王》</p><p>66.所谓理想，只是同时拥有实力的人才能说的“现实”。——尾田荣一郎《海贼王》</p><p>67.背部受伤是身为剑客的耻辱。——罗罗亚•索隆《海贼王》</p><p>68.真正的强者也是会有找不到出拳的理由的，同样的，我也找不到去骂人的理由！——马歇尔•D•蒂奇《海贼王》</p><p>69.路飞，你听得到么？我让你担心了吧？我如果不能成为世界第一的大剑客的话，你会很困扰对吧？我绝对，绝对不会再被人打败了。在打赢那个人成为世界第一之前，我绝不会再被任何人打败！你有什么不满意的么？海贼王！——罗罗诺亚•索隆《海贼王》</p><p>70.“听着，路飞。我们一定要过一段无怨无悔的人生。将来一定要出海，随心所欲地活着。比谁都要自由。”——波特卡斯•D•艾斯《海贼王》</p>]]></content>
      
      
      <categories>
          
          <category> 生活小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海贼王 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/09/05/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/05/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h4 id="创建线程的方式？"><a href="#创建线程的方式？" class="headerlink" title="创建线程的方式？"></a>创建线程的方式？</h4><p>待续。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加班的周六</title>
      <link href="/2020/09/05/Life/diary01/"/>
      <url>/2020/09/05/Life/diary01/</url>
      
        <content type="html"><![CDATA[<h3 id="人生哪能多如意，万事只求半称心"><a href="#人生哪能多如意，万事只求半称心" class="headerlink" title="人生哪能多如意，万事只求半称心"></a>人生哪能多如意，万事只求半称心</h3><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/Lifediary01.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr+GitHub+PicGo搭建图床</title>
      <link href="/2020/08/31/constructTools/jsDelivr+GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/08/31/constructTools/jsDelivr+GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="jsDelivr-GitHub-PicGo搭建图床"><a href="#jsDelivr-GitHub-PicGo搭建图床" class="headerlink" title="jsDelivr+GitHub+PicGo搭建图床"></a>jsDelivr+GitHub+PicGo搭建图床</h3><blockquote><ul><li>目前GITHUB仓库容量是没有上限的！不过官方推荐在1G以内！</li><li>仓库单个文件50M会收到警告，大于100M会被拒绝！</li><li>jsDelivr仅能针对50M以下的文件CDN加速！</li></ul></blockquote><h4 id="1、新建GitHub仓库"><a href="#1、新建GitHub仓库" class="headerlink" title="1、新建GitHub仓库"></a>1、新建GitHub仓库</h4><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPIcGo_100.png"></p><h4 id="2、生成登录GitHub的token认证"><a href="#2、生成登录GitHub的token认证" class="headerlink" title="2、生成登录GitHub的token认证"></a>2、生成登录GitHub的token认证</h4><ol><li>主页依次选择【Settings】</li><li>【Developer settings】</li><li>【Personal access tokens】</li><li>【Generate new token】</li></ol><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPIcGo_100.png"></p><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPicGo_101.png"></p><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPicGo_102.png"></p><p><img src="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPicGo_104.png"></p><h4 id="3、配置PicGo"><a href="#3、配置PicGo" class="headerlink" title="3、配置PicGo"></a>3、配置PicGo</h4><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p></blockquote><ul><li><strong>设定仓库名：</strong>按照【用户名 &#x2F; 图床仓库名】的格式填写</li><li><strong>设定分支名：</strong>【master】</li><li><strong>设定Token：</strong>粘贴之前生成的【Token】</li><li><strong>指定存储路径：</strong>填写想要储存的路径，如【JavaBolg&#x2F;】，这样就会在仓库下创建一个名为JavaBolg 的文件夹，图片将会储存在此文件夹中</li><li><strong>设定自定义域名：</strong>它的作用是，在图片上传后，PicGo会按照【<code>自定义域名+储存路径+上传的图片名</code>】的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名</code> 】，上传完毕后，我们就可以通过【<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</code>】加速访问我们的图片了，比如：<a href="https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPigGo_9.jpg">https://cdn.jsdelivr.net/gh/OrangeMaid/jsDelivrPic/JavaBolgPigGo_9.jpg</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试复盘</title>
      <link href="/2020/08/31/interviewAnalyse/interviewByCong/"/>
      <url>/2020/08/31/interviewAnalyse/interviewByCong/</url>
      
        <content type="html"><![CDATA[<h1 id="被问到的面试题"><a href="#被问到的面试题" class="headerlink" title="被问到的面试题"></a>被问到的面试题</h1><p><a name="oVo80"></a></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>1.多线程的四种创建方式？</strong><br /> public static ExecutorService newFixedThreadPool(int nThreads)；<br /> public static ExecutorService newCachedThreadPool()；<br /> public static ExecutorService newSingleThreadExecutor()；<br /> public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)；<br />**2.创建多线程的参数？<img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598238683736-936eda0e-bc61-44bd-bdd3-9b61b6c3081f.png#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=132&originWidth=510&size=0&status=done&style=none&width=510"><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598244649988-a9d5a439-226f-4961-9d7c-50fc2da01bec.png#align=left&display=inline&height=296&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1892&size=88071&status=done&style=none&width=946" alt="image.png"><br /> 核心线程数，最大线程数，没有任务时线程最大存活时间，时间单位，队列，线程创建工厂用来定义线程名，拒绝策略<br />线程池7个参数详解：<a href="https://blog.csdn.net/ye17186/article/details/89467919">https://blog.csdn.net/ye17186/article/details/89467919</a><br /><strong>3.多线程的死锁问题排查</strong><br />使用jdk自带工具进行排查<br />执行jps指令，可以查看当前运行的线程：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598239934822-bd603738-e41a-403a-beb7-4cf0ba77aa03.png#align=left&display=inline&height=75&margin=%5Bobject%20Object%5D&originHeight=75&originWidth=341&size=0&status=done&style=none&width=341"><br /><br><br />可以看到Run线程的id值为3684。在执行jstack -l 3684命令，查看结果</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598240098558-9f5b0f96-edd5-46a5-8ff8-90167345b6d4.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=890&size=112582&status=done&style=none&width=445" alt="image.png"><br /><br><br /><a href="https://blog.csdn.net/dancheng1/article/details/80984956">https://blog.csdn.net/dancheng1/article/details/80984956</a><br /></p><p><a name="vXjkv"></a></p><h2 id="java类加载器"><a href="#java类加载器" class="headerlink" title="java类加载器"></a>java类加载器</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598257421990-670b9cf2-512e-4c09-ae64-dd8b6e1f2b87.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=338&originWidth=501&size=0&status=done&style=none&width=501"><br />双亲委派机制<br />当一个类加载器收到了类加载请求，它会把这个请求委派给父（parent）类加载器去完成，依次递归，因此所有的加载请求最终都被传送到顶层的启动类加载器中。只有在父类加载器无法加载该类时子类才尝试从自己类的路径中加载该类。<br />ExtClassLoader加载的类是属于$JRE_HOME&#x2F;lib&#x2F;ext下面的扩展类<br />AppClassLoader是用于加载各个不同应用下面的类<br />Bootstrap Classloader 默认是负责加载$JRE_HOME&#x2F;lib目录下面的类<br />自定义类加载器：<br />1.实现findClass 双亲委派<br />2.重写loadClass 根据自定义加载<br /></p><p><a name="tXXow"></a></p><h2 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598324032430-ab054f43-e46d-4467-9112-79d4a9eef132.png#align=left&display=inline&height=591&margin=%5Bobject%20Object%5D&originHeight=591&originWidth=643&size=0&status=done&style=none&width=643"><br /><br><br />多线程共享内存区域:<strong>方法区、堆。</strong><br />每一个线程独享内存:<strong>java栈、本地方法栈、程序计数器。</strong><br /><strong>程序计数器：</strong>较小的内存空间，<strong>当前线程执行的字节码的行号指示器</strong>；各线程之间独立存储，互不影响；<br /><strong>java 栈：</strong>线程私有，生命周期和线程，每个方法在执行的同时都会创建一个 栈帧用于<strong>存储局部变量表，操作数栈，动态链接，方法出口等信息</strong>。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程；栈里面存放着各种基本数据类型和对象的引用；<br /><strong>本地方法栈：</strong>本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，<strong>JVM只是简单地动态链接并直接调用native方法</strong>；<br /><strong>堆：</strong>Java堆是程序员需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等)；<br /><strong>方法区：</strong>也叫永久区，用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)等数据。**(jdk1.8已经将方法区去掉了，将方法区移动到直接内存)**<br /><strong>运行时常量池：****运行时常量池是方法区的一部分</strong>，用于存放编译期生成的各种字面(“zdy”,”123”等)和符号引用。<br /><strong>直接内存：</strong>不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；<br />1）如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；<br />2） 这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；<br /></p><p><a name="ah8ZZ"></a></p><h2 id="jvm内存调优"><a href="#jvm内存调优" class="headerlink" title="jvm内存调优"></a>jvm内存调优</h2><p><a href="https://www.cnblogs.com/beyondcj/p/6273487.html">https://www.cnblogs.com/beyondcj/p/6273487.html</a><br /><br><br /></p><p><a name="mdhfg"></a></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><a href="https://blog.csdn.net/yubujian_l/article/details/80804708">https://blog.csdn.net/yubujian_l&#x2F;article&#x2F;details&#x2F;80804708</a><br /><br><br /></p><p><a name="EzThx"></a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><a name="ykbDY"></a></p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>保证对象在jvm中只有一个实例 ，常见实现 懒汉式，饿汉式</p><ul><li>懒汉式：需要的时候才加载，线程不安全</li><li>饿汉式：初始化的时候就加载，线程安全<br><a name="cyGDp"></a></li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>实现创建者和调用者分离 spring IOC<br><a name="8OVYX"></a></p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。既(AOP微         实现)  ,AOP核心技术面向切面编程。</p><ul><li>静态代理(静态定义代理类)</li><li>动态代理(动态生成代理类)<ul><li>Jdk自带动态代理 实现InvocationHandler </li><li>Cglib 、javaassist（字节码操作库）实现MethodInterceptor** **</li></ul></li></ul><p><a name="j7stF"></a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><strong>1.MySql如何优化？</strong></p><ul><li>先定位慢查询，MySQL默认10秒内没有响应SQL结果，则为慢查询，可以通过show status like ‘slow_queries’;</li><li>查询慢查询次数，然后做sql优化，比如使用group by分组查询时后面增加order by null防止排序，</li><li>使用连接代替子查询因为join不会在内存中创建临时表，</li><li>在where及order by涉及的列上建立索引，避免全表扫描，</li><li>避免在where子句中对字段进行null值判断等等，</li><li>根据规则分库分表，读写分离，</li><li>对mysql配置优化，配置最大并发数my.ini, 调整缓存大小等等</li></ul><p>(1)表的设计合理化(符合3NF)<br />1F：原子约束，每列不可再分<br />2F：保证唯一性，非主键列依赖主键列<br />3F：不要有冗余列（不一定完全要遵循）<br />(2)添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]<br />索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时是全表扫描，而使用索引无需扫描任何记录即可迅速定位目标记录所在位置<br />索引实现原理：索引的实现通常使用 B 树及其变种 B+ 树，每次创建索引都会生成对应的索引文件<br />为什么使用B树（原理）？<br />B树采用的是二分查找，从根节点开始向下搜索子节点，直到命中结束<br />(3)SQL语句优化<br />慢查询：MySQL默认10秒内没有响应SQL结果,则为慢查询<br />显示慢查询次数：show status like ‘slow_queries’;<br />查询慢查询时间：show variables like ‘long_query_time’;<br />修改慢查询时间：set long_query_time&#x3D;1; —但是重启mysql之后，long_query_time依然是my.ini中的值<br /><br><br /><br><br /><br><br /><strong>2.对索引的了解有多少？主键索引和唯一索引的区别？</strong></p><ul><li>主键一定是唯一性索引，唯一性索引并不一定就是主键</li><li>一个表中可以有多个唯一性索引，但只能有一个主键</li><li>主键列不允许空值，而唯一性索引列允许空值</li></ul><p><strong>3.redis 哪些数据类型？</strong><br />(一)String<br />这个其实没啥好说的，最常规的set&#x2F;get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。<br />(二)hash<br />这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。<br />(三)list<br />使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。<br />(四)set<br />因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br />另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br />(五)sorted set<br />sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。<br /><strong>4.redis是单线程还是多线程？</strong><br />单线程<br /><strong>5.为什么redis是单线程？</strong><br />“因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。”<br /><strong>6.为什么redis是单线程还这么快？</strong><br />       1.redis是基于内存的，内存的读写速度非常快；<br />2.redis是单线程的，省去了很多上下文切换线程的时间；<br />3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简            单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io            上浪费一点时间。<br />这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路I&#x2F;O复用技术可以让单个    线程高效的处理多个连接请求<br /></p><p><a name="pldm8"></a></p><h2 id="GIT命令"><a href="#GIT命令" class="headerlink" title="GIT命令"></a>GIT命令</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/506565/1598251218507-988c0dcf-ed6a-4380-a1e3-543eee99fb8e.png#align=left&display=inline&height=252&margin=%5Bobject%20Object%5D&originHeight=3162&originWidth=1759&size=0&status=done&style=none&width=140"><br /><br><br />提交代码：<br />git add<br />git commit<br />git push<br />切换分支<br /> git checkout -b newBranchName<br />回退代码：<br />git revert<br />解决冲突：<br /><br><br />**<br /></p><p><a name="wZPck"></a></p><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><p><strong>1..spring mvc 工作原理</strong><br />详解：<a href="https://www.cnblogs.com/hamawep789/p/10840774.html">https://www.cnblogs.com/hamawep789/p/10840774.html</a></p><ul><li>用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</li><li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li><li>HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</li><li>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</li><li>6、DispatcherServlet将模型数据填充到视图中</li><li>7、DispatcherServlet将结果响应给用户</li></ul><p><strong>2.spring aop</strong><br />面向切面<br />实现AOP的主要设计模式就是动态代理。<br />Spring的动态代理有两种：一是JDK的动态代理；另一个是cglib动态代理。<br /><strong>3.spring ioc <strong><br />控制bean与bean之间</strong>的关系</strong><br />Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。实现IOC的主要设计模式是工厂模式。<br />详解：<a href="https://www.jianshu.com/p/78ba8bafb90a">https://www.jianshu.com/p/78ba8bafb90a</a><br />spring 常见面试题总结：<a href="https://blog.csdn.net/a745233700/article/details/80959716">https://blog.csdn.net/a745233700/article/details/80959716</a><br><a name="50wFf"></a></p><h2 id="Jmeter工作原理"><a href="#Jmeter工作原理" class="headerlink" title="Jmeter工作原理"></a>Jmeter工作原理</h2><p>jmeter作为浏览器与web服务器之间的代理网关，可以捕获浏览器的请求和web服务器的响应，通过线程来模拟真实用户对web服务器的访问压力。基本原理是建立一个线程池，多线程运行取样器产生大量负载，在运行过程中通过断言来验证结果的正确性，可以通过监听来记录测试结果。<br />如果取样器中有参数化需求，可以通过配置元件或者前置处理器来完成；<br />如果取样器中有关联需求，可以通过后置处理器来完成；<br />如果要模拟负载场景，比如模拟多少用户，运动多长时间，可以通过线程组完成；<br />如果要模拟并发场景，可以通过定时器来完成；<br />如果要控制业务的执行逻辑，比如登录只运行一次，可以通过控制器来完成；<br /></p><p><a name="Vq8Wz"></a></p><h2 id="持续集成思想"><a href="#持续集成思想" class="headerlink" title="持续集成思想"></a>持续集成思想</h2><p>持续集成（Continuous Integration）、持续交付（Continuous Delivery）和持续部署（Continuous Deployment）其目的是减少代码改动到投入生产的所需时间，提早发现风险、减少QA的测试时长、减少运维的人工干预。整体上是一个提效的过程。<br /><a href="https://www.cnblogs.com/rexcheny/p/12214998.html">https://www.cnblogs.com/rexcheny/p/12214998.html</a><br />TODO:<br />猪齿鱼Choerodon有待研究<br /></p><p><a name="fdqvf"></a></p><h2 id="测试计划包括哪些内容"><a href="#测试计划包括哪些内容" class="headerlink" title="测试计划包括哪些内容"></a>测试计划包括哪些内容</h2><ol><li>概述 1.1 编写目的 1.2 项目背景 1.3 项目质量目标 1.4 预期读者 1.5 参考资料</li><li>测试环境 2.1 系统架构 2.2 软硬件环境要求 2.3 测试环境部署图</li><li>测试规划 3.1 测试范围 3.2 测试工具 3.3 人员、角色及职责</li><li>测试策略 4.1 系统框测试 4.2 业务流程测试 4.3 功能点测试 4.4 UI界面测试 4.5 性能测试 4.6 兼容性测试 4.7 安全测试</li><li>测试进度安排</li><li>工作汇报<br><a name="7gpEG"></a></li></ol><h2 id="测试报告包括哪些内容"><a href="#测试报告包括哪些内容" class="headerlink" title="测试报告包括哪些内容"></a>测试报告包括哪些内容</h2><blockquote><blockquote><blockquote><p>测试资源概述——多少人、多长时间  <br />&gt;&gt;&gt;测试结果摘要——分别描述各个测试需求的测试结果，产品实现了哪些功能点，哪些还没有实现  <br />&gt;&gt;&gt;缺陷分析——按照缺陷的属性分类进行分析  <br />&gt;&gt;&gt;测试需求覆盖率——原先列举的测试需求的测试覆盖率，可能一部分测试需求因为资源和优先级的因素没有进行测试，那么在这里要进行说明  <br />&gt;&gt;&gt;测试评估——从总体对项目质量进行评估  <br />&gt;&gt;&gt;测试组建议——从测试组的角度为项目组提出工作建议<br /></p></blockquote></blockquote></blockquote><p><a name="WZrO4"></a></p><h2 id="给你一个登录系统怎么测"><a href="#给你一个登录系统怎么测" class="headerlink" title="给你一个登录系统怎么测"></a>给你一个登录系统怎么测</h2><p>1.功能测试 </p><ul><li>正常的用户名密码，</li><li>错误的用户名密码，提示信息是否友好，</li><li>输入空，null，中文，特殊字符，</li><li>输入框是否有长度限制，</li><li>密码框是否加密显示，</li><li>输入正确的验证码，</li><li>输入错误的验证码，</li><li>验证码有效时间，</li></ul><p>2.界面测试</p><ul><li>布局是否合理美观，输入框是否对齐，按钮排列正常</li><li>文字和图片显示正常</li><li>输入框是否有默认文案</li><li>登录按钮是否可用，页面刷新后退功能是否可用</li><li>快捷键 tab enter esc 是否能控制使用</li></ul><p>3.性能测试</p><ul><li>单用户登录系统的响应时间是否符合”2-5-8”原则</li><li>用户数在临界点时并发登录是否还能符合”2-5-8”原则</li><li>压力：大量并发用户登录，系统的响应时间是多少？系统会出现宕机、内存泄露、cpu饱和、无法登录吗?</li><li>稳定性： 系统能否处理并发用户数在临界点以内连续登录N个时的场景？</li></ul><p>4.安全性测试</p><ul><li>用户名和密码是否通过加密的方式，发送给Web服务器</li><li>错误登录的次数限制（防止暴力破解）</li><li>用户名和密码的验证，应该是前端验证+服务器端验证， 而不能单单是在客户端用javascript验证</li><li>用户名和密码的输入框，无SQL 注入攻击风险</li><li>用户名和密码的的输入框，不能输入脚本 （防止XSS攻击）</li></ul><p>5.兼容性测试<br />不同的浏览器，不同的操作系统，不同分辨率下页面展示是否正常<br />6.易用性测试</p><ul><li>是否有记住密码的功能</li><li>是否支持复制粘贴编辑</li><li>是否允许多端同时登录</li></ul><p>7.是否需要考虑埋点测试，实时追踪用户浏览轨迹<br /></p><p><a name="9rvIy"></a></p><h2 id="如何保障一个系统的稳定"><a href="#如何保障一个系统的稳定" class="headerlink" title="如何保障一个系统的稳定"></a>如何保障一个系统的稳定</h2><p><a href="https://www.cnblogs.com/vinsent/p/12093649.html">https://www.cnblogs.com/vinsent/p/12093649.html</a><br />可感知，可预防，可快速处理<br><a name="KKzRu"></a></p><h4 id="业务监控方面："><a href="#业务监控方面：" class="headerlink" title="业务监控方面："></a>业务监控方面：</h4><p>需要有链路追踪功能，能实时反映用户的操作，从客户端发起一个请求一直到服务端的整个过程。每个阶段的耗时，花销，调用等信息，方便定位故障发生的位置，缩短问题处理时间。关注PV,UV,QPS,错误状态码请求量，请求耗时；<br><a name="41yjZ"></a></p><h4 id="应用监控方面："><a href="#应用监控方面：" class="headerlink" title="应用监控方面："></a>应用监控方面：</h4><p>支撑业务运行的框架或系统的监控信息<br />常见的监控内容：</p><ul><li>jvm内存，垃圾回收，cpu占用情况</li><li>sql执行次数，时间</li><li>并发情况处理<br><a name="6djkB"></a></li></ul><h4 id="系统监控方面："><a href="#系统监控方面：" class="headerlink" title="系统监控方面："></a>系统监控方面：</h4><p>系统监控就是硬件方面的要求</p><ul><li>RT页面平均响应时间</li><li>网卡流量</li><li>各个状态端口监控</li><li>网络，交换机，带宽容量</li></ul><br /><br />异常报警，线上巡检，应用拆分，故障演练，应急预案，一键切流，一键降级<br /><br />1.监控宝<br />2.能做主从的就主从，反正就是不要有单点，而且相同的服务不能部署在一个服务器上，尽量不要在一个网段、机房<br />3.自动切换和备份<br />4.集群，高可用<br />5.如果服务挂了，自动重启<br />6.集群 ，失败转移 ，负载均衡， 实时监控， 备份<p><a name="roJwZ"></a></p><h2 id="如何测试整个交易模块"><a href="#如何测试整个交易模块" class="headerlink" title="如何测试整个交易模块"></a>如何测试整个交易模块</h2><br /><br />]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/28/hello-world/"/>
      <url>/2020/08/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/08/27/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/08/27/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="乐观锁悲观锁试用场景"><a href="#乐观锁悲观锁试用场景" class="headerlink" title="乐观锁悲观锁试用场景?"></a>乐观锁悲观锁试用场景?</h3><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。<br>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><h3 id="java面试题之什么是死锁、活锁、饿死和竞态条件？"><a href="#java面试题之什么是死锁、活锁、饿死和竞态条件？" class="headerlink" title="java面试题之什么是死锁、活锁、饿死和竞态条件？"></a>java面试题之什么是死锁、活锁、饿死和竞态条件？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，他们将无法推进下去；</p><p>活锁：是指两个线程优先级相同，都礼让不走，就这样一直僵持下去；</p><p>饿死：在单线程情况下，A、B两个线程，A先执行；A在执行过程中，C线程来了，B让C先执行；C在执行过程中，D线程来了，B也让D先执行，就这样B一直都是等待状态。</p><p>竞态条件：多个线程竞争同一个变量，导致数据的不正确性，线程的访问顺序是不可控的，会影响最终的结果。</p><h4 id="产生死锁的必要条件："><a href="#产生死锁的必要条件：" class="headerlink" title="产生死锁的必要条件："></a>产生死锁的必要条件：</h4><p>1、互斥使用（资源独占）</p><p>　　一个资源每次只能给一个进程使用（比如写操作）</p><p>2、占有且等待：</p><p>　　进程在申请新的资源的同时，保持对原有资源的占有</p><p>3、不可抢占：</p><p>　　资源申请者不能强行从资源占有者手动夺取资源，资源只能由占有者自愿释放</p><p>4、循环等待：</p><p>　　A等待B占有的资源，B等待C占有的资源，C等待D占有的资源，……….N等待A的资源，形成一个线程等待回路</p><h3 id="stop-和-suspend-方法为何不推荐使用？"><a href="#stop-和-suspend-方法为何不推荐使用？" class="headerlink" title="stop() 和 suspend() 方法为何不推荐使用？"></a>stop() 和 suspend() 方法为何不推荐使用？</h3><p>反对使用 stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。<br>suspend() 方法容易发生死锁。调用 suspend() 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被 “挂起” 的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait() 命其进入等待状态。若标志指出线程应当恢复，则用一个 notify() 重新启动线程。</p><h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别?"></a>sleep() 和 wait() 有什么区别?</h3><p>1.sleep()不会释放当前占有的锁,sleep(long)会导致</p><p>2.sleep()线程进入 TIMED-WATING 状态,而 wait()方法会导致当前线程进入 WATING 状态</p><p><del>sleep 就是正在执行的线程主动让出 cpu，cpu 去执行其他线程，在 sleep 指定的时间过后，cpu 才会回到这个线程上继续往下执行，<br>如果当前线程进入了同步锁，sleep 方法并不会释放锁，即使当前线程使用 sleep 方法让出了 cpu，但其他被同步锁挡住了的线程也无法得到执行。<br>wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了 notify 方法（notify 并不释放锁，<br>只是告诉调用过 wait 方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果 notify 方法后面的代码还有很多，<br>需要这些代码执行完后才会释放锁，可以在 notfiy 方法后增加一个等待和一些代码，看看效果），调用 wait 方法的线程就会解除 wait 状态和程序可以再次得到锁后继续向下运行。</del></p><h3 id="当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法"><a href="#当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?"></a>当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?</h3><p>其他方法前是否加了 synchronized 关键字，如果没加，则能。<br>如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。<br>如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。<br>如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是 this。</p><h3 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h3><p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。<br>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p><h3 id="volatile-变量是什么？volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量是什么？volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？</h3><p>volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。<br>volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。<br>volatile 有两个功用：<br>这个变量不会在多个线程中存在复本，直接从内存读取。<br>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</p><h3 id="volatile-类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？"><a href="#volatile-类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？"></a>volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？</h3><p>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。<br>在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获到（简单的赋值与返回操作的）原子性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2020/08/27/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/27/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="3-4-Map"><a href="#3-4-Map" class="headerlink" title="3.4. Map"></a>3.4. Map</h1><p><img src="/images/collection/map/Map.png" alt="alt"></p><h2 id="3-4-1-HashMap-数组-链表-红黑树"><a href="#3-4-1-HashMap-数组-链表-红黑树" class="headerlink" title="3.4.1. HashMap(数组+链表+红黑树)"></a>3.4.1. HashMap(数组+链表+红黑树)</h2><p>HashMap 根据键的 hashCode 值存储数据,大多数情况下可以直接定位到它的值,因而具有很快<br>的访问速度,但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null,允许多条记<br>录的值为 null。HashMap 非线程安全,即任一时刻可以有多个线程同时写 HashMap,可能会导<br>致数据的不一致。如果需要满足线程安全,可以用 Collections 的 synchronizedMap 方法使<br>HashMap 具有线程安全的能力,或者使用 ConcurrentHashMap。我们用下面这张图来介绍<br>HashMap 的结构。</p><h3 id="3-4-1-1-JAVA7-实现"><a href="#3-4-1-1-JAVA7-实现" class="headerlink" title="3.4.1.1.  JAVA7 实现"></a>3.4.1.1.  JAVA7 实现</h3><p><img src="/images/collection/map/HashMap7.png" alt="alt"><br>大方向上,HashMap 里面是一个数组,然后数组中每个元素是一个单向链表。上图中,每个绿色<br>的实体是嵌套类 Entry 的实例,Entry 包含四个属性:key, value, hash 值和用于单向链表的 next。</p><ol><li>capacity:当前数组容量,始终保持 2^n,可以扩容,扩容后数组大小为当前的 2 倍。</li><li>loadFactor:负载因子,默认为 0.75。<br>3.threshold:扩容的阈值,等于 capacity * loadFactor</li></ol><h3 id="3-4-1-2-JAVA8-实现"><a href="#3-4-1-2-JAVA8-实现" class="headerlink" title="3.4.1.2.  JAVA8 实现"></a>3.4.1.2.  JAVA8 实现</h3><p>Java8 对 HashMap 进行了一些修改,最大的不同就是利用了红黑树,所以其由 数组+链表+红黑<br>树 组成。<br>根据 Java7 HashMap 的介绍,我们知道,查找的时候,根据 hash 值我们能够快速定位到数组的<br>具体下标,但是之后的话,需要顺着链表一个个比较下去才能找到我们需要的,时间复杂度取决<br>于链表的长度,为 O(n)。为了降低这部分的开销,在 Java8 中,当链表中的元素超过了 8 个以后,<br>会将链表转换为红黑树,在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/images/collection/map/HashMap8.png" alt="alt"></p><h2 id="3-4-2-ConcurrentHashMap"><a href="#3-4-2-ConcurrentHashMap" class="headerlink" title="3.4.2. ConcurrentHashMap"></a>3.4.2. ConcurrentHashMap</h2><h3 id="3-4-2-1-Segment-段"><a href="#3-4-2-1-Segment-段" class="headerlink" title="3.4.2.1. Segment 段"></a>3.4.2.1. Segment 段</h3><p>ConcurrentHashMap 和 HashMap 思路是差不多的,但是因为它支持并发操作,所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成,Segment 代表”部分“或”一段“的<br>意思,所以很多地方都会将其描述为分段锁。注意,行文中,我很多地方用了“槽”来代表一个<br>segment。</p><h3 id="3-4-2-2-线程安全-Segment-继承-ReentrantLock-加锁"><a href="#3-4-2-2-线程安全-Segment-继承-ReentrantLock-加锁" class="headerlink" title="3.4.2.2.  线程安全(Segment 继承 ReentrantLock 加锁)"></a>3.4.2.2.  线程安全(Segment 继承 ReentrantLock 加锁)</h3><p>简单理解就是,ConcurrentHashMap 是一个 Segment 数组,Segment 通过继承<br>ReentrantLock 来进行加锁,所以每次需要加锁的操作锁住的是一个 segment,这样只要保证每<br>个 Segment 是线程安全的,也就实现了全局的线程安全。<br><img src="/images/collection/map/ConcurrentHashMap7.png" alt="alt"></p><h3 id="3-4-2-3-并行度-默认-16"><a href="#3-4-2-3-并行度-默认-16" class="headerlink" title="3.4.2.3.  并行度(默认 16)"></a>3.4.2.3.  并行度(默认 16)</h3><p>concurrencyLevel:并行级别、并发数、Segment 数,怎么翻译不重要,理解它。默认是 16,<br>也就是说 ConcurrentHashMap 有 16 个 Segments,所以理论上,这个时候,最多可以同时支<br>持 16 个线程并发写,只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值,但是一旦初始化以后,它是不可以扩容的。再具体到每个 Segment 内部,其实<br>每个 Segment 很像之前介绍的 HashMap,不过它要保证线程安全,所以处理起来要麻烦些。</p><h3 id="3-4-2-4-Java8-实现-引入了红黑树"><a href="#3-4-2-4-Java8-实现-引入了红黑树" class="headerlink" title="3.4.2.4.  Java8 实现 (引入了红黑树)"></a>3.4.2.4.  Java8 实现 (引入了红黑树)</h3><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。<br><img src="/images/collection/map/ConcurrentHashMap8.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 搭建博客日志</title>
      <link href="/2019/08/05/hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/08/05/hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-搭建博客日志"><a href="#hexo-搭建博客日志" class="headerlink" title="hexo 搭建博客日志"></a>hexo 搭建博客日志</h1><h2 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看<br>##hexo 搭建步骤</p><ol><li>安装git</li><li>安装node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库h</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>发布文章</li></ol><h2 id="1、安装git"><a href="#1、安装git" class="headerlink" title="1、安装git"></a>1、安装git</h2><p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。<br>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2、安装node-js"><a href="#2、安装node-js" class="headerlink" title="2、安装node.js"></a>2、安装node.js</h2><p>进入nodejs官网选择LTS版本安装即可<br>安装完成后，执行一下命令，检查是否安装成功，检查版本号</p><pre class="line-numbers language-none"><code class="language-none">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3、安装hexo"><a href="#3、安装hexo" class="headerlink" title="3、安装hexo"></a>3、安装hexo</h2><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。使用<code>hexo -v</code> 来查看版本号。</p><p>输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化bolg文件夹 ： <code>hexo init myblog</code><br>然后进入blog文件夹执行命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> blog //进入这个myblog文件夹<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所有命令执行完成后，bolg文件夹应该有如下目录：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>Hexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。</li><li>generate 生成静态文件。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>server 启动服务器<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>deploy 部署网站。部署网站前，需要预先生成静态文件。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>卸载Hexo<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> uninstall hexo-cli <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
